<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>redis on kinnylee</title>
    <link>https://kinnylee.github.io/tags/redis/</link>
    <description>Recent content in redis on kinnylee</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020; all rights reserved.</copyright>
    <lastBuildDate>Sun, 28 Jun 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://kinnylee.github.io/tags/redis/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>K8s基本入门</title>
      <link>https://kinnylee.github.io/post/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/</link>
      <pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://kinnylee.github.io/post/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/</guid>
      <description>前言  redis性能为什么这么出色？它与其他缓存中间件有什么区别？ redis底层使用了哪些数据结构支撑它如此高效的性能？ 内部丰富的数据类型底层为什么都使用至少两种数据结构实现？分别是什么？ 如果合理的使用redis才能发挥它最大的优势？  学习完《redis设计与实现》前面关于数据结构与对象的章节，以上问题都能得到解答。你也能了解到redis作者如此的煞费苦心设计了这么多丰富的数据结构，目的就是优化内存。学完这些内容，在使用redis的过程中，也会合理的使用以适应它内部的特点。当然新版本的redis支持了更多更丰富的特性，该书基于redis3版本，还没有涉及到那些内容。
《redis设计与实现》这本书非常浅显易懂，作者黄建宏老师，90后。另外还是《redis实战》的译者
另一篇可参考《redis设计与实现》2-数据库实现篇
概述 特点  c语言开发，性能出色，纯内存操作，每秒可处理超过10w读写（QPS） 多种数据结构，单个最大限制可到1GB(memcached只支持字符串，最大1M) 受物理内存限制，不能作海量数据的读写。适用于较小数据量的高性能操作和运算上 支持事务，持久化 单线程模型（memcached是多线程）  支持的数据类型  Sring List Set SortedSet hash Bitmap Hyperloglogs Geo pub/sub  redis为什么这么快  纯内存操作，没有磁盘io 单线程处理请求，没有线程切换开销和竞争条件，也不存在加锁问题 多路复用模型epoll，非阻塞io(多路：多个网络连接；复用：复用同一个线程) 多路复用技术可以让单个线程高效的处理多个连接请求 数据结构简单，对数据操作也简单。还做了自己的数据结构优化  redis为什么是单线程的  单线程已经很快了，减少多线程带来的网络开销，锁操作 后续的4.0版本在考虑多线程 单线程是指处理网络请求的时候只有一个线程，并不是redis-server只有一个线程在工作。持久化的时候，就是通过fork一个子线程来执行。 缺点：耗时的命令会导致并发的下降，比如keys *  redis的回收策略  volatile-lru：从过期的数据集 server.db[i].expires中挑选最近最少使用的数据 volatile-ttl：从过期的数据集 server.db[i].expires中挑选将要过期的数据淘汰 volatile-random： server.db[i].expires中挑选任意数据淘汰 allkeys-lru: 从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-enviction（驱逐）：禁止驱逐数据  使用注意  redis单线程无法发挥多核cpu性能，可以通过单机开多个redis实例来完善 redis实现分布式锁：先用setnx（如果不存在才设置）争抢锁，抢到后，expire设置过期时间，防止忘记释放。 redis实现一对多消息订阅：sub/pub数据结构 redis实现延时消息队列：zadd时间戳作为score 消费的时候根据时间戳+延时时间做查询操作。  各大版本介绍 redis5版本新增功能：  zpopmax zpopmin以及阻塞变种：返回集合中给定分值最大最小的数据数量  reids4版本新增功能：  模块功能，提供类似于插件的方式，自己开发一个.</description>
    </item>
    
  </channel>
</rss>